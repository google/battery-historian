// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package analyzer runs the Historian state machine code on the uploaded bugreport.
package analyzer

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"html/template"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"strconv"
	"strings"

	"github.com/golang/protobuf/proto"

	"github.com/google/battery-historian/checkinparse"
	"github.com/google/battery-historian/checkinutil"
	"github.com/google/battery-historian/packageutils"
	"github.com/google/battery-historian/parseutils"
	"github.com/google/battery-historian/presenter"

	bspb "github.com/google/battery-historian/pb/batterystats_proto"
	sessionpb "github.com/google/battery-historian/pb/session_proto"
)

const (
	maxFileSize     = 50 * 1024 * 1024 // 50 MB Limit
	minSupportedSDK = 21               // We only support Lollipop bug reports and above
)

var (
	// Initialized in InitTemplates()
	uploadTempl *template.Template
	resultTempl *template.Template

	isOptimizedJs bool
)

type historianData struct {
	html string
	err  error
}

type summariesData struct {
	summaries    []parseutils.ActivitySummary
	historianCsv string
	errs         []error
}

type checkinData struct {
	batterystats *bspb.BatteryStats
	warnings     []string
	err          []error
}

// InitTemplates initializes the HTML templates.
func InitTemplates() {
	uploadTempl = template.Must(template.ParseFiles(
		"templates/base.html", "templates/body.html", "templates/upload.html"),
	)

	// base.html is intentionally excluded from resultTempl. resultTempl is loaded into the HTML
	// generated by uploadTempl, so attempting to include base.html here causes some of the
	// javascript files to be imported twice, which causes things to start blowing up.
	resultTempl = template.Must(template.ParseFiles(
		"templates/body.html", "templates/summaries.html"),
	)
}

// SetIsOptimized sets whether the JS will be optimized.
func SetIsOptimized(optimized bool) {
	isOptimizedJs = optimized
}

func closeConnection(w http.ResponseWriter, s string) {
	if flusher, ok := w.(http.Flusher); ok {
		w.Header().Set("Connection", "close")
		w.Header().Set("Content-Length", fmt.Sprintf("%d", len(s)))
		w.WriteHeader(http.StatusExpectationFailed)
		io.WriteString(w, s)
		flusher.Flush()
	}
	fmt.Println(s, " Closing connection.")
	conn, _, _ := w.(http.Hijacker).Hijack()
	conn.Close()
}

// UploadHandler is the main analysis function.
func UploadHandler(w http.ResponseWriter, r *http.Request) {
	// If false, the upload template will load closure and js files in the header.
	uploadData := struct {
		IsOptimizedJs bool
	}{
		isOptimizedJs,
	}

	switch r.Method {
	//GET displays the upload form.
	case "GET":
		if err := uploadTempl.Execute(w, uploadData); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

	//POST takes the uploaded file(s) and saves it to disk.
	case "POST":
		// Do not accept files that are greater than 50 MBs
		if r.ContentLength > maxFileSize {
			closeConnection(w, "File too large (>50MB).")
			return
		}
		r.Body = http.MaxBytesReader(w, r.Body, maxFileSize)

		//get the multipart reader for the request.
		reader, err := r.MultipartReader()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		log.Printf("Trace Starting reading uploaded file. %d bytes", r.ContentLength)

		//copy each part to destination.
		for {
			part, err := reader.NextPart()
			if err == io.EOF {
				break
			}

			//if part.FileName() is empty, skip this iteration.
			if part == nil || part.FileName() == "" {
				continue
			}

			b, err := ioutil.ReadAll(part)
			if err != nil {
				http.Error(w, "Failed to read file. Please try again.", http.StatusInternalServerError)
				return
			}

			contentType := http.DetectContentType(b)
			if !strings.Contains(contentType, "text/plain") {
				http.Error(w, "Incorrect file format detected", http.StatusInternalServerError)
				return
			}

			log.Printf("Trace started analyzing file.")

			// Generate the Historian plot and parsing simultaneously.
			historianCh := make(chan historianData)
			summariesCh := make(chan summariesData)
			checkinCh := make(chan checkinData)

			contents := string(b)
			// Create a temporary file to save bug report, for the Historian script.
			tmpFile, err := ioutil.TempFile("", "historian")

			historianOutput := historianData{"", err}
			if err == nil {
				// Don't run the Historian script if could not create temporary file.
				fname := tmpFile.Name()
				defer os.Remove(fname)
				tmpFile.WriteString(contents)
				tmpFile.Close()
				go func() {
					html, err := generateHistorianPlot(w, part.FileName(), fname)
					historianCh <- historianData{html, err}
					log.Printf("Trace finished generating Historian plot.")
				}()
			}

			var errs []error
			sdk, err := sdkVersion(contents)
			if sdk < minSupportedSDK {
				errs = append(errs, errors.New("unsupported bug report version"))
			}
			if err != nil {
				errs = append(errs, err)
			}

			if sdk >= minSupportedSDK {
				// No point running these if we don't support the sdk version since we won't get any data from them.
				go func() {
					o, c, errs := analyze(contents)
					summariesCh <- summariesData{o, c, errs}
					log.Printf("Trace finished processing summary data.")
				}()

				go func() {
					var ctr checkinutil.IntCounter

					/* Extract Build Fingerprint from the bugreport. */
					s := &sessionpb.Checkin{
						Checkin:          proto.String(contents),
						BuildFingerprint: proto.String(extractBuildFingerprint(contents)),
					}
					pkgs, pkgErrs := packageutils.ExtractAppsFromBugReport(contents)
					stats, warnings, pbsErrs := checkinparse.ParseBatteryStats(&ctr, checkinparse.CreateCheckinReport(s), pkgs)
					checkinCh <- checkinData{stats, warnings, append(pkgErrs, pbsErrs...)}
				}()
			}

			if historianOutput.err == nil {
				historianOutput = <-historianCh
			}
			if historianOutput.err != nil {
				historianOutput.html = fmt.Sprintf("Error generating historian plot: %v", historianOutput.err)
			}

			var summariesOutput summariesData
			var checkinOutput checkinData
			if sdk >= minSupportedSDK {
				summariesOutput = <-summariesCh
				checkinOutput = <-checkinCh
				errs = append(errs, append(summariesOutput.errs, checkinOutput.err...)...)
			}

			log.Printf("Trace finished generating Historian plot and summaries.")

			data := presenter.Data(sdk, modelName(contents), summariesOutput.historianCsv, part.FileName(), summariesOutput.summaries, checkinOutput.batterystats, historianOutput.html, checkinOutput.warnings, errs)

			if err := resultTempl.Execute(w, data); err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
			}

			log.Printf("Trace ended analyzing file.")
		}
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
	}
}

func analyze(bugreport string) ([]parseutils.ActivitySummary, string, []error) {
	var b bytes.Buffer
	rep := parseutils.AnalyzeHistory(bugreport, parseutils.FormatTotalTime, &b, false)

	// Exclude summaries with no change in battery level
	var a []parseutils.ActivitySummary
	for _, s := range rep.Summaries {
		if s.InitialBatteryLevel != s.FinalBatteryLevel {
			a = append(a, s)
		}
	}
	return a, b.String(), rep.Errs
}

// generateHistorianPlot calls the Historian python script to generate html charts.
func generateHistorianPlot(w http.ResponseWriter, reportName, filepath string) (string, error) {
	cmd := exec.Command("./historian.py", "-c", "-m", "-r", reportName, filepath)
	// Stdout pipe for reading the generated Historian output.
	cmdStdout, stdoutErr := cmd.StdoutPipe()
	if stdoutErr != nil {
		return "", stdoutErr
	}

	// Run the Historian script.
	if err := cmd.Start(); err != nil {
		return "", err
	}

	outputCh := make(chan string)
	go getStdout(w, cmdStdout, outputCh)

	// Read the output generated by historian.
	output := <-outputCh

	if err := cmd.Wait(); err != nil {
		return "", err
	}
	return output, nil
}

// getStdout reads the output generated by Historian.
func getStdout(w http.ResponseWriter, stdout io.ReadCloser, outputChan chan string) {
	scanner := bufio.NewScanner(stdout)
	var buffer bytes.Buffer
	for scanner.Scan() {
		buffer.WriteString(scanner.Text() + "\n")
	}
	outputChan <- buffer.String()
}

func sdkVersion(input string) (int, error) {
	// Found in the System Properties section of a bug report.
	re := regexp.MustCompile(`.*\[ro.build.version.sdk\]:\s+\[(?P<sdkVersion>\d+)\].*`)
	if match, result := parseutils.SubexpNames(re, input); match {
		return strconv.Atoi(result["sdkVersion"])
	}
	return -1, errors.New("unable to find device SDK version")
}

// modelName returns the device's model name (ie. Nexus 5).
func modelName(input string) string {
	// Found in the System Properties section of a bug report.
	re := regexp.MustCompile(`.*\[ro.product.model\]:\s+\[(?P<modelName>.*)\].*`)
	if match, result := parseutils.SubexpNames(re, input); match {
		return result["modelName"]
	}
	// We should only get to this point in the case of a bad (malformed) bug report.
	return "unknown device"
}

func extractBuildFingerprint(input string) string {
	// A regular expression to match any build fingerprint line in the bugreport.
	re := regexp.MustCompile("Build\\s+fingerprint:\\s+'(?P<build>\\S+)'")
	var out string
	for _, line := range strings.Split(input, "\n") {
		if match, result := parseutils.SubexpNames(re, line); match {
			out = result["build"]
			break
		}
	}
	return out
}
